diff --git a/CMakeLists.txt b/CMakeLists.txt
index c91ebe62..ed306782 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -74,6 +74,9 @@ extend_qtc_plugin(SpellChecker
     suggestionsdialog.cpp
     suggestionsdialog.h
     suggestionsdialog.ui
+    runextensions.h
+    runextensions.cpp
+    functiontraits.h
 )
 
 extend_qtc_plugin(SpellChecker
diff --git a/SpellChecker.json.in b/SpellChecker.json.in
index a5576a6d..e988c1be 100644
--- a/SpellChecker.json.in
+++ b/SpellChecker.json.in
@@ -1,32 +1,32 @@
 {
-    \"Name\" : \"SpellChecker\",
-    \"Version\" : \"3.4.0\",
-    \"CompatVersion\" : \"3.4.0\",
-    \"Vendor\" : \"Carel Combrink\",
-    \"Copyright\" : \"(C) 2015 - 2022 Carel Combrink\",
-    \"License\" : [ \"GNU Lesser General Public License Usage\",
-                  \"\",
-                  \"This plugin may be used under the terms of the GNU Lesser General Public License version 2.1 or version 3 as published by the Free Software Foundation.  Please review the following information to ensure the GNU Lesser General Public License requirements will be met: https://www.gnu.org/licenses/lgpl.html and http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\"
+    "Name" : "SpellChecker",
+    "Version" : "3.4.0",
+    "CompatVersion" : "3.4.0",
+    "Vendor" : "Carel Combrink",
+    "Copyright" : "(C) 2015 - 2022 Carel Combrink",
+    "License" : [ "GNU Lesser General Public License Usage",
+                  "",
+                  "This plugin may be used under the terms of the GNU Lesser General Public License version 2.1 or version 3 as published by the Free Software Foundation.  Please review the following information to ensure the GNU Lesser General Public License requirements will be met: https://www.gnu.org/licenses/lgpl.html and http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html."
     ],
-    \"Description\" : [ \"Spellcheck comments in source files.\",
-                      \"An Output Pane, Right Click context menu and a Navigation Widget is added to QtCreator to interact with the results from this plugin.\"
+    "Description" : [ "Spellcheck comments in source files.",
+                      "An Output Pane, Right Click context menu and a Navigation Widget is added to QtCreator to interact with the results from this plugin."
     ],
-    \"Url\" : \"https://github.com/CJCombrink/SpellChecker-Plugin\",
-    $$dependencyList,
+    "Url" : "https://github.com/CJCombrink/SpellChecker-Plugin",
+    ${IDE_PLUGIN_DEPENDENCIES},
 
-    \"Mimetypes\" : [
-        \"<?xml version=\'1.0\' encoding=\'UTF-8\'?>\",
-        \"<mime-info xmlns=\'http://www.freedesktop.org/standards/shared-mime-info\'>\",
-        \"    <mime-type type=\'text/x-c++dox\'>\",
-        \"        <sub-class-of type=\'text/x-c++hdr\'/>\",
-        \"        <comment>Doxygen Files</comment>\",
-        \"        <glob pattern=\'*.dox\'/>\",
-        \"        <glob pattern=\'*.doxy\'/>\",
-        \"        <magic priority=\'50\'>\",
-        \"              <match type=\'string\' offset=\'0\' value=\'/*!\'/>\",
-        \"              <match type=\'string\' offset=\'0\' value=\'/**\'/>\",
-        \"        </magic>\",
-        \"    </mime-type>\",
-        \"</mime-info>\"
+    "Mimetypes" : [
+        "<?xml version=\'1.0\' encoding=\'UTF-8\'?>",
+        "<mime-info xmlns=\'http://www.freedesktop.org/standards/shared-mime-info\'>",
+        "    <mime-type type=\'text/x-c++dox\'>",
+        "        <sub-class-of type=\'text/x-c++hdr\'/>",
+        "        <comment>Doxygen Files</comment>",
+        "        <glob pattern=\'*.dox\'/>",
+        "        <glob pattern=\'*.doxy\'/>",
+        "        <magic priority=\'50\'>",
+        "              <match type=\'string\' offset=\'0\' value=\'/*!\'/>",
+        "              <match type=\'string\' offset=\'0\' value=\'/**\'/>",
+        "        </magic>",
+        "    </mime-type>",
+        "</mime-info>"
     ]
 }
diff --git a/src/Parsers/CppParser/cppdocumentparser.cpp b/src/Parsers/CppParser/cppdocumentparser.cpp
index 3e6b449c..09c3bab7 100644
--- a/src/Parsers/CppParser/cppdocumentparser.cpp
+++ b/src/Parsers/CppParser/cppdocumentparser.cpp
@@ -21,6 +21,7 @@
 #include "../../spellcheckerconstants.h"
 #include "../../spellcheckercore.h"
 #include "../../spellcheckercoresettings.h"
+#include "../../runextensions.h"
 #include "../../Word.h"
 #include "cppdocumentparser.h"
 #include "cppdocumentprocessor.h"
@@ -41,7 +42,6 @@
 #include <texteditor/texteditor.h>
 #include <utils/algorithm.h>
 #include <utils/mimeutils.h>
-#include <utils/runextensions.h>
 #include <utils/qtcassert.h>
 
 #include <QApplication>
diff --git a/src/Parsers/CppParser/cppparsersettings.cpp b/src/Parsers/CppParser/cppparsersettings.cpp
index da713729..a2e91682 100644
--- a/src/Parsers/CppParser/cppparsersettings.cpp
+++ b/src/Parsers/CppParser/cppparsersettings.cpp
@@ -23,6 +23,7 @@
 #include "cppparsersettings.h"
 
 #include "../../spellcheckerconstants.h"
+#include "utils/qtcsettings.h"
 
 using namespace SpellChecker::CppSpellChecker::Internal;
 using namespace SpellChecker::CppSpellChecker;
@@ -56,26 +57,26 @@ CppParserSettings::~CppParserSettings()
 {}
 // --------------------------------------------------
 
-void CppParserSettings::loadFromSettings( QSettings* settings )
+void CppParserSettings::loadFromSettings( Utils::QtcSettings* settings )
 {
   setDefaults();
 
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_PARSERS_GROUP ) );
-  settings->beginGroup( QLatin1String( Parsers::CppParser::Constants::CPP_PARSER_GROUP ) );
-
-  whatToCheck                   = static_cast<WhatToCheckOptions>( settings->value( QLatin1String( Parsers::CppParser::Constants::WHAT_TO_CHECK ), int(whatToCheck) ).toInt() );
-  commentsToCheck               = static_cast<CommentsToCheckOptions>( settings->value( QLatin1String( Parsers::CppParser::Constants::COMMENTS_TO_CHECK ), int(commentsToCheck) ).toInt() );
-  checkQtKeywords               = settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_QT_KEYWORDS ), checkQtKeywords ).toBool();
-  checkAllCapsWords             = settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_CAPS ), checkAllCapsWords ).toBool();
-  wordsWithNumberOption         = static_cast<WordsWithNumbersOption>( settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_NUMBERS ), wordsWithNumberOption ).toInt() );
-  wordsWithUnderscoresOption    = static_cast<WordsWithUnderscoresOption>( settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_UNDERSCORES ), wordsWithUnderscoresOption ).toInt() );
-  camelCaseWordOption           = static_cast<CamelCaseWordOption>( settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_CAMELCASE ), camelCaseWordOption ).toInt() );
-  removeWordsThatAppearInSource = settings->value( QLatin1String( Parsers::CppParser::Constants::REMOVE_WORDS_SOURCE ), removeWordsThatAppearInSource ).toBool();
-  removeEmailAddresses          = settings->value( QLatin1String( Parsers::CppParser::Constants::REMOVE_EMAIL_ADDRESSES ), removeEmailAddresses ).toBool();
-  wordsWithDotsOption           = static_cast<WordsWithDotsOption>( settings->value( QLatin1String( Parsers::CppParser::Constants::CHECK_DOTS ), wordsWithDotsOption ).toInt() );
-  removeWebsites                = settings->value( QLatin1String( Parsers::CppParser::Constants::REMOVE_WEBSITES ), removeWebsites ).toBool();
-  removeFirstComment            = settings->value( QLatin1String( Parsers::CppParser::Constants::REMOVE_FIRST_COMMENT ), removeFirstComment ).toBool();
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup( Constants::CORE_PARSERS_GROUP );
+  settings->beginGroup( Parsers::CppParser::Constants::CPP_PARSER_GROUP );
+
+  whatToCheck                   = static_cast<WhatToCheckOptions>( settings->value( Parsers::CppParser::Constants::WHAT_TO_CHECK, int(whatToCheck) ).toInt() );
+  commentsToCheck               = static_cast<CommentsToCheckOptions>( settings->value( Parsers::CppParser::Constants::COMMENTS_TO_CHECK, int(commentsToCheck) ).toInt() );
+  checkQtKeywords               = settings->value( Parsers::CppParser::Constants::CHECK_QT_KEYWORDS, checkQtKeywords ).toBool();
+  checkAllCapsWords             = settings->value( Parsers::CppParser::Constants::CHECK_CAPS, checkAllCapsWords ).toBool();
+  wordsWithNumberOption         = static_cast<WordsWithNumbersOption>( settings->value( Parsers::CppParser::Constants::CHECK_NUMBERS, wordsWithNumberOption ).toInt() );
+  wordsWithUnderscoresOption    = static_cast<WordsWithUnderscoresOption>( settings->value( Parsers::CppParser::Constants::CHECK_UNDERSCORES, wordsWithUnderscoresOption ).toInt() );
+  camelCaseWordOption           = static_cast<CamelCaseWordOption>( settings->value( Parsers::CppParser::Constants::CHECK_CAMELCASE, camelCaseWordOption ).toInt() );
+  removeWordsThatAppearInSource = settings->value( Parsers::CppParser::Constants::REMOVE_WORDS_SOURCE, removeWordsThatAppearInSource ).toBool();
+  removeEmailAddresses          = settings->value( Parsers::CppParser::Constants::REMOVE_EMAIL_ADDRESSES, removeEmailAddresses ).toBool();
+  wordsWithDotsOption           = static_cast<WordsWithDotsOption>( settings->value( Parsers::CppParser::Constants::CHECK_DOTS, wordsWithDotsOption ).toInt() );
+  removeWebsites                = settings->value( Parsers::CppParser::Constants::REMOVE_WEBSITES, removeWebsites ).toBool();
+  removeFirstComment            = settings->value( Parsers::CppParser::Constants::REMOVE_FIRST_COMMENT, removeFirstComment ).toBool();
 
   settings->endGroup(); /* CPP_PARSER_GROUP */
   settings->endGroup(); /* CORE_PARSERS_GROUP */
@@ -85,24 +86,24 @@ void CppParserSettings::loadFromSettings( QSettings* settings )
 // --------------------------------------------------
 
 
-void CppParserSettings::saveToSetting( QSettings* settings ) const
+void CppParserSettings::saveToSetting( Utils::QtcSettings* settings ) const
 {
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_PARSERS_GROUP ) );
-  settings->beginGroup( QLatin1String( Parsers::CppParser::Constants::CPP_PARSER_GROUP ) );
-
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::WHAT_TO_CHECK ),          int(whatToCheck) );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::COMMENTS_TO_CHECK ),      int(commentsToCheck) );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_QT_KEYWORDS ),      checkQtKeywords );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_CAPS ),             checkAllCapsWords );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_NUMBERS ),          wordsWithNumberOption );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_UNDERSCORES ),      wordsWithUnderscoresOption );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_CAMELCASE ),        camelCaseWordOption );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::REMOVE_WORDS_SOURCE ),    removeWordsThatAppearInSource );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::REMOVE_EMAIL_ADDRESSES ), removeEmailAddresses );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::CHECK_DOTS ),             wordsWithDotsOption );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::REMOVE_WEBSITES ),        removeWebsites );
-  settings->setValue( QLatin1String( Parsers::CppParser::Constants::REMOVE_FIRST_COMMENT ),   removeFirstComment );
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup( Constants::CORE_PARSERS_GROUP );
+  settings->beginGroup( Parsers::CppParser::Constants::CPP_PARSER_GROUP );
+
+  settings->setValue( Parsers::CppParser::Constants::WHAT_TO_CHECK,          int(whatToCheck) );
+  settings->setValue( Parsers::CppParser::Constants::COMMENTS_TO_CHECK,      int(commentsToCheck) );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_QT_KEYWORDS,      checkQtKeywords );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_CAPS,             checkAllCapsWords );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_NUMBERS,          wordsWithNumberOption );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_UNDERSCORES,      wordsWithUnderscoresOption );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_CAMELCASE,        camelCaseWordOption );
+  settings->setValue( Parsers::CppParser::Constants::REMOVE_WORDS_SOURCE,    removeWordsThatAppearInSource );
+  settings->setValue( Parsers::CppParser::Constants::REMOVE_EMAIL_ADDRESSES, removeEmailAddresses );
+  settings->setValue( Parsers::CppParser::Constants::CHECK_DOTS,             wordsWithDotsOption );
+  settings->setValue( Parsers::CppParser::Constants::REMOVE_WEBSITES,        removeWebsites );
+  settings->setValue( Parsers::CppParser::Constants::REMOVE_FIRST_COMMENT,   removeFirstComment );
 
   settings->endGroup(); /* CPP_PARSER_GROUP */
   settings->endGroup(); /* CORE_PARSERS_GROUP */
diff --git a/src/Parsers/CppParser/cppparsersettings.h b/src/Parsers/CppParser/cppparsersettings.h
index c261f79d..d3dba1bd 100644
--- a/src/Parsers/CppParser/cppparsersettings.h
+++ b/src/Parsers/CppParser/cppparsersettings.h
@@ -20,6 +20,7 @@
 
 #pragma once
 
+#include "utils/qtcsettings.h"
 #include <QObject>
 #include <QSettings>
 
@@ -147,8 +148,8 @@ public:
                                            * will not be ignored. This is to handle pure doxygen
                                            * docs files that might start without a file header. */
 
-  void loadFromSettings( QSettings* settings );
-  void saveToSetting( QSettings* settings ) const;
+  void loadFromSettings(Utils::QtcSettings* settings);
+  void saveToSetting(Utils::QtcSettings* settings) const;
 
   CppParserSettings& operator=( const CppParserSettings& other );
   bool operator==( const CppParserSettings& other ) const;
diff --git a/src/SpellCheckers/HunspellChecker/hunspellchecker.cpp b/src/SpellCheckers/HunspellChecker/hunspellchecker.cpp
index 703f0219..da54823b 100644
--- a/src/SpellCheckers/HunspellChecker/hunspellchecker.cpp
+++ b/src/SpellCheckers/HunspellChecker/hunspellchecker.cpp
@@ -34,7 +34,7 @@
 #include <QMutex>
 #include <QSharedPointer>
 #include <QTextCodec>
-#include <QRegularExpression>
+#include <QRegularExpression>
 
 #include <memory>
 
@@ -190,12 +190,12 @@ QString HunspellChecker::name() const
 
 void HunspellChecker::loadSettings()
 {
-  QSettings* settings = Core::ICore::settings();
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_SPELLCHECKERS_GROUP ) );
-  settings->beginGroup( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTINGS_GROUP ) );
-  d->dictionary     = settings->value( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTING_DICTIONARY ), QLatin1String( "" ) ).toString();
-  d->userDictionary = settings->value( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTING_USER_DICTIONARY ), QLatin1String( "" ) ).toString();
+  auto* settings = Core::ICore::settings();
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup( Constants::CORE_SPELLCHECKERS_GROUP );
+  settings->beginGroup( SpellCheckers::HunspellChecker::Constants::SETTINGS_GROUP );
+  d->dictionary     = settings->value( SpellCheckers::HunspellChecker::Constants::SETTING_DICTIONARY, "" ).toString();
+  d->userDictionary = settings->value( SpellCheckers::HunspellChecker::Constants::SETTING_USER_DICTIONARY, "" ).toString();
   settings->endGroup();
   settings->endGroup();
   settings->endGroup();
@@ -228,12 +228,12 @@ void HunspellChecker::loadUserAddedWords()
 
 void HunspellChecker::saveSettings() const
 {
-  QSettings* settings = Core::ICore::settings();
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_SPELLCHECKERS_GROUP ) );
-  settings->beginGroup( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTINGS_GROUP ) );
-  settings->setValue( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTING_DICTIONARY ),      d->dictionary );
-  settings->setValue( QLatin1String( SpellCheckers::HunspellChecker::Constants::SETTING_USER_DICTIONARY ), d->userDictionary );
+  auto* settings = Core::ICore::settings();
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup( Constants::CORE_SPELLCHECKERS_GROUP );
+  settings->beginGroup( SpellCheckers::HunspellChecker::Constants::SETTINGS_GROUP );
+  settings->setValue( SpellCheckers::HunspellChecker::Constants::SETTING_DICTIONARY,      d->dictionary );
+  settings->setValue( SpellCheckers::HunspellChecker::Constants::SETTING_USER_DICTIONARY, d->userDictionary );
   settings->endGroup();
   settings->endGroup();
   settings->endGroup();
diff --git a/src/functiontraits.h b/src/functiontraits.h
new file mode 100644
index 00000000..8b052d3e
--- /dev/null
+++ b/src/functiontraits.h
@@ -0,0 +1,169 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0
+
+#pragma once
+
+#include <tuple>
+
+namespace Utils {
+
+/*
+    struct functionTraits<Function>
+    {
+        using ResultType; // Return type of Function
+        struct argument<unsigned index>
+        {
+            using type; // type of Function argument at index (starting with 0)
+        }
+    }
+
+    struct functionTakesArgument<Function, unsigned index, ArgumentType>;
+
+    Is derived from std::true_type if Function takes an argument of type ArgumentType at index.
+    Otherwise derived from std::false_type.
+*/
+
+////////////////////
+// functionTraits
+////////////////////
+
+// for callables. defined below.
+template <typename Callable>
+struct functionTraits;
+
+// function
+template <typename Result, typename... Args>
+struct functionTraits<Result(Args...)>
+{
+    using ResultType = Result;
+    static const unsigned arity = sizeof...(Args); // TODO const -> constexpr with MSVC2015
+
+    template <unsigned i>
+    struct argument
+    {
+        using type = typename std::tuple_element<i, std::tuple<Args...>>::type;
+    };
+};
+
+// function pointer
+template <typename Result, typename... Args>
+struct functionTraits<Result(*)(Args...)> : public functionTraits<Result(Args...)>
+{
+};
+
+// const function pointer
+template <typename Result, typename... Args>
+struct functionTraits<Result(* const)(Args...)> : public functionTraits<Result(Args...)>
+{
+};
+
+// member function
+template <typename Type, typename Result, typename... Args>
+struct functionTraits<Result(Type::*)(Args...)> : public functionTraits<Result(Type&,Args...)>
+{
+};
+
+// const member function
+template <typename Type, typename Result, typename... Args>
+struct functionTraits<Result(Type::*)(Args...) const> : public functionTraits<Result(Type&,Args...)>
+{
+};
+
+// const pointer to member function
+template <typename Type, typename Result, typename... Args>
+struct functionTraits<Result(Type::* const)(Args...)> : public functionTraits<Result(Type&,Args...)>
+{
+};
+
+// const pointer to const member function
+template <typename Type, typename Result, typename... Args>
+struct functionTraits<Result(Type::* const)(Args...) const> : public functionTraits<Result(Type&,Args...)>
+{
+};
+
+// TODO: enable lvalue and rvalue ref member function later (MSVC 2015?)
+//// lvalue ref member function
+//template <typename Type, typename Result, typename... Args>
+//struct functionTraits<Result(Type::*)(Args...) &> : public functionTraits<Result(Type&,Args...)>
+//{
+//};
+
+//// const lvalue ref member function
+//template <typename Type, typename Result, typename... Args>
+//struct functionTraits<Result(Type::*)(Args...) const &> : public functionTraits<Result(Type&,Args...)>
+//{
+//};
+
+//// rvalue ref member function
+//template <typename Type, typename Result, typename... Args>
+//struct functionTraits<Result(Type::*)(Args...) &&> : public functionTraits<Result(Type&,Args...)>
+//{
+//};
+
+// callables. only works if operator() is not overloaded.
+template <typename Callable>
+struct functionTraits
+{
+    using callableTraits = functionTraits<decltype(&Callable::operator())>;
+    using ResultType = typename callableTraits::ResultType;
+    static const unsigned arity = callableTraits::arity - 1; // ignore object pointer arg // TODO const -> constexpr with MSVC2015
+
+    template <unsigned i>
+    struct argument
+    {
+        using type = typename callableTraits::template argument<i+1>::type; // ignore object pointer arg
+    };
+};
+
+// lvalue ref callables
+template <typename Callable>
+struct functionTraits<Callable&> : public functionTraits<Callable>
+{
+};
+
+// const lvalue ref callables
+template <typename Callable>
+struct functionTraits<const Callable&> : public functionTraits<Callable>
+{
+};
+
+// rvalue ref callables
+template <typename Callable>
+struct functionTraits<Callable&&> : public functionTraits<Callable>
+{
+};
+
+template <typename F>
+using functionResult_t = typename functionTraits<F>::ResultType;
+
+////////////////////
+// functionTakesArgument
+////////////////////
+namespace Internal {
+
+template <typename HasArity/*true_type or false_type*/,
+          typename Function, unsigned index, typename T>
+struct functionTakesArgumentArityDispatch;
+
+template <typename Function, unsigned index, typename T>
+struct functionTakesArgumentArityDispatch<std::false_type, Function, index, T>
+        : public std::false_type
+{
+};
+
+template <typename Function, unsigned index, typename T>
+struct functionTakesArgumentArityDispatch<std::true_type, Function, index, T>
+        : public std::is_same<T, typename functionTraits<Function>::template argument<index>::type>
+{
+};
+
+} // Internal
+
+template <typename Function, unsigned index, typename T>
+struct functionTakesArgument : public Internal::functionTakesArgumentArityDispatch<
+        std::integral_constant<bool, (functionTraits<Function>::arity > index)>,
+        Function, index, T>
+{
+};
+
+} // Utils
diff --git a/src/outputpane.cpp b/src/outputpane.cpp
index 17c8e6fe..dca469bb 100644
--- a/src/outputpane.cpp
+++ b/src/outputpane.cpp
@@ -262,13 +262,13 @@ void OutputPane::loadColumnSizes()
   int colLine    = 40;
   int colColumn  = 40;
 
-  QSettings* settings = Core::ICore::settings();
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_OP_GROUP ) );
-  colWord    = settings->value( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_WORD ), colWord ).toInt();
-  colLiteral = settings->value( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_LITERAL ), colLiteral ).toInt();
-  colLine    = settings->value( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_LINE ), colLine ).toInt();
-  colColumn  = settings->value( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_COLUMN ), colColumn ).toInt();
+  auto* settings = Core::ICore::settings();
+  settings->beginGroup(Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup(Constants::CORE_SETTINGS_OP_GROUP );
+  colWord    = settings->value(Constants::SETTINGS_OUTPUT_PANE_COL_WORD, colWord ).toInt();
+  colLiteral = settings->value(Constants::SETTINGS_OUTPUT_PANE_COL_LITERAL, colLiteral ).toInt();
+  colLine    = settings->value(Constants::SETTINGS_OUTPUT_PANE_COL_LINE, colLine ).toInt();
+  colColumn  = settings->value(Constants::SETTINGS_OUTPUT_PANE_COL_COLUMN, colColumn ).toInt();
   settings->endGroup(); /* CORE_SETTINGS_OP_GROUP */
   settings->endGroup(); /* CORE_SETTINGS_GROUP */
 
@@ -282,13 +282,13 @@ void OutputPane::loadColumnSizes()
 void OutputPane::saveColumnSizes()
 {
   /* Save the table sizes to the settings file. */
-  QSettings* settings = Core::ICore::settings();
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_OP_GROUP ) );
-  settings->setValue( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_WORD ),    d->treeView->columnWidth( Constants::MISTAKE_COLUMN_WORD ) );
-  settings->setValue( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_LITERAL ), d->treeView->columnWidth( Constants::MISTAKE_COLUMN_LITERAL ) );
-  settings->setValue( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_LINE ),    d->treeView->columnWidth( Constants::MISTAKE_COLUMN_LINE ) );
-  settings->setValue( QLatin1String( Constants::SETTINGS_OUTPUT_PANE_COL_COLUMN ),  d->treeView->columnWidth( Constants::MISTAKE_COLUMN_COLUMN ) );
+  auto* settings = Core::ICore::settings();
+  settings->beginGroup(Constants::CORE_SETTINGS_GROUP );
+  settings->beginGroup(Constants::CORE_SETTINGS_OP_GROUP );
+  settings->setValue(Constants::SETTINGS_OUTPUT_PANE_COL_WORD,    d->treeView->columnWidth( Constants::MISTAKE_COLUMN_WORD ) );
+  settings->setValue(Constants::SETTINGS_OUTPUT_PANE_COL_LITERAL, d->treeView->columnWidth( Constants::MISTAKE_COLUMN_LITERAL ) );
+  settings->setValue(Constants::SETTINGS_OUTPUT_PANE_COL_LINE,    d->treeView->columnWidth( Constants::MISTAKE_COLUMN_LINE ) );
+  settings->setValue(Constants::SETTINGS_OUTPUT_PANE_COL_COLUMN,  d->treeView->columnWidth( Constants::MISTAKE_COLUMN_COLUMN ) );
   settings->endGroup(); /* CORE_SETTINGS_OP_GROUP */
   settings->endGroup(); /* CORE_SETTINGS_GROUP */
   settings->sync();
diff --git a/src/runextensions.cpp b/src/runextensions.cpp
new file mode 100644
index 00000000..efcd73a6
--- /dev/null
+++ b/src/runextensions.cpp
@@ -0,0 +1,23 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0
+
+#include "runextensions.h"
+
+namespace Utils {
+namespace Internal {
+
+RunnableThread::RunnableThread(QRunnable *runnable, QObject *parent)
+    : QThread(parent),
+      m_runnable(runnable)
+{
+}
+
+void RunnableThread::run()
+{
+    m_runnable->run();
+    if (m_runnable->autoDelete())
+        delete m_runnable;
+}
+
+} // Internal
+} // Utils
diff --git a/src/runextensions.h b/src/runextensions.h
new file mode 100644
index 00000000..cead735a
--- /dev/null
+++ b/src/runextensions.h
@@ -0,0 +1,477 @@
+// Copyright (C) 2016 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only WITH Qt-GPL-exception-1.0
+
+#pragma once
+
+#include "functiontraits.h"
+
+#include <QCoreApplication>
+#include <QFuture>
+#include <QFutureInterface>
+#include <QFutureWatcher>
+#include <QRunnable>
+#include <QThread>
+#include <QThreadPool>
+
+#include <functional>
+
+// hasCallOperator & Co must be outside of any namespace
+// because of internal compiler error with MSVC2015 Update 2
+
+using testCallOperatorYes = char;
+using testCallOperatorNo = struct { char foo[2]; };
+
+template<typename C>
+static testCallOperatorYes testCallOperator(decltype(&C::operator()));
+
+template<typename>
+static testCallOperatorNo testCallOperator(...);
+
+template<typename T>
+struct hasCallOperator
+{
+    static const bool value = (sizeof(testCallOperator<T>(nullptr)) == sizeof(testCallOperatorYes));
+};
+
+namespace Utils {
+
+namespace Internal {
+
+/*
+   resultType<F>::type
+
+   Returns the type of results that would be reported by a callable of type F
+   when called through the runAsync methods. I.e. the ResultType in
+
+   void f(QFutureInterface<Result> &fi, ...)
+   ResultType f(...)
+
+   Returns void if F is not callable, and if F is a callable that does not take
+   a QFutureInterface& as its first parameter and returns void.
+*/
+
+template <typename Function>
+struct resultType;
+
+template <typename Function, typename Arg>
+struct resultTypeWithArgument;
+
+template <typename Function, int index, bool>
+struct resultTypeTakesArguments;
+
+template <typename Function, bool>
+struct resultTypeIsMemberFunction;
+
+template <typename Function, bool>
+struct resultTypeIsFunctionLike;
+
+template <typename Function, bool>
+struct resultTypeHasCallOperator;
+
+template <typename Function, typename ResultType>
+struct resultTypeWithArgument<Function, QFutureInterface<ResultType>&>
+{
+    using type = ResultType;
+};
+
+template <typename Function, typename Arg>
+struct resultTypeWithArgument
+{
+    using type = functionResult_t<Function>;
+};
+
+template <typename Function, int index>
+struct resultTypeTakesArguments<Function, index, true>
+        : public resultTypeWithArgument<Function, typename functionTraits<Function>::template argument<index>::type>
+{
+};
+
+template <typename Function, int index>
+struct resultTypeTakesArguments<Function, index, false>
+{
+    using type = functionResult_t<Function>;
+};
+
+template <typename Function>
+struct resultTypeIsFunctionLike<Function, true>
+        : public resultTypeTakesArguments<Function, 0, (functionTraits<Function>::arity > 0)>
+{
+};
+
+template <typename Function>
+struct resultTypeIsMemberFunction<Function, true>
+        : public resultTypeTakesArguments<Function, 1, (functionTraits<Function>::arity > 1)>
+{
+};
+
+template <typename Function>
+struct resultTypeIsMemberFunction<Function, false>
+{
+    using type = void;
+};
+
+template <typename Function>
+struct resultTypeIsFunctionLike<Function, false>
+        : public resultTypeIsMemberFunction<Function, std::is_member_function_pointer<Function>::value>
+{
+};
+
+template <typename Function>
+struct resultTypeHasCallOperator<Function, false>
+        : public resultTypeIsFunctionLike<Function, std::is_function<std::remove_pointer_t<std::decay_t<Function>>>::value>
+{
+};
+
+template <typename Callable>
+struct resultTypeHasCallOperator<Callable, true>
+        : public resultTypeTakesArguments<Callable, 0, (functionTraits<Callable>::arity > 0)>
+{
+};
+
+template <typename Function>
+struct resultType
+        : public resultTypeHasCallOperator<Function, hasCallOperator<Function>::value>
+{
+};
+
+template <typename Function>
+struct resultType<Function&> : public resultType<Function>
+{
+};
+
+template <typename Function>
+struct resultType<const Function&> : public resultType<Function>
+{
+};
+
+template <typename Function>
+struct resultType<Function &&> : public resultType<Function>
+{
+};
+
+template <typename Function>
+struct resultType<std::reference_wrapper<Function>> : public resultType<Function>
+{
+};
+template <typename Function>
+struct resultType<std::reference_wrapper<const Function>> : public resultType<Function>
+{
+};
+
+/*
+   Callable object that wraps a member function pointer with the object it
+   will be called on.
+*/
+
+template <typename Function>
+class MemberCallable;
+
+template <typename Result, typename Obj, typename... Args>
+class MemberCallable<Result(Obj::*)(Args...) const>
+{
+public:
+    MemberCallable(Result(Obj::* function)(Args...) const, const Obj *obj)
+        : m_function(function),
+          m_obj(obj)
+    {
+    }
+
+    Result operator()(Args&&... args) const
+    {
+        return ((*m_obj).*m_function)(std::forward<Args>(args)...);
+    }
+
+private:
+    Result(Obj::* m_function)(Args...) const;
+    const Obj *m_obj;
+};
+
+template <typename Result, typename Obj, typename... Args>
+class MemberCallable<Result(Obj::*)(Args...)>
+{
+public:
+    MemberCallable(Result(Obj::* function)(Args...), Obj *obj)
+        : m_function(function),
+          m_obj(obj)
+    {
+    }
+
+    Result operator()(Args&&... args) const
+    {
+        return ((*m_obj).*m_function)(std::forward<Args>(args)...);
+    }
+
+private:
+    Result(Obj::* m_function)(Args...);
+    Obj *m_obj;
+};
+
+/*
+   Helper functions for runAsync that run in the started thread.
+*/
+
+// void function that does not take QFutureInterface
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncReturnVoidDispatch(std::true_type, QFutureInterface<ResultType> &, Function &&function, Args&&... args)
+{
+    function(std::forward<Args>(args)...);
+}
+
+// non-void function that does not take QFutureInterface
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncReturnVoidDispatch(std::false_type, QFutureInterface<ResultType> &futureInterface, Function &&function, Args&&... args)
+{
+    futureInterface.reportResult(function(std::forward<Args>(args)...));
+}
+
+// function that takes QFutureInterface
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncQFutureInterfaceDispatch(std::true_type, QFutureInterface<ResultType> &futureInterface, Function &&function, Args&&... args)
+{
+    function(futureInterface, std::forward<Args>(args)...);
+}
+
+// function that does not take QFutureInterface
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncQFutureInterfaceDispatch(std::false_type, QFutureInterface<ResultType> &futureInterface, Function &&function, Args&&... args)
+{
+    runAsyncReturnVoidDispatch(std::is_void<std::invoke_result_t<Function, Args...>>(),
+                               futureInterface, std::forward<Function>(function), std::forward<Args>(args)...);
+}
+
+// function, function pointer, or other callable object that is no member pointer
+template <typename ResultType, typename Function, typename... Args,
+          typename = std::enable_if_t<!std::is_member_pointer<std::decay_t<Function>>::value>
+         >
+void runAsyncMemberDispatch(QFutureInterface<ResultType> &futureInterface, Function &&function, Args&&... args)
+{
+    runAsyncQFutureInterfaceDispatch(functionTakesArgument<Function, 0, QFutureInterface<ResultType>&>(),
+                                     futureInterface, std::forward<Function>(function), std::forward<Args>(args)...);
+}
+
+// Function = member function
+template <typename ResultType, typename Function, typename Obj, typename... Args,
+          typename = std::enable_if_t<std::is_member_pointer<std::decay_t<Function>>::value>
+         >
+void runAsyncMemberDispatch(QFutureInterface<ResultType> &futureInterface, Function &&function, Obj &&obj, Args&&... args)
+{
+    // Wrap member function with object into callable
+    runAsyncImpl(futureInterface,
+                 MemberCallable<std::decay_t<Function>>(std::forward<Function>(function), std::forward<Obj>(obj)),
+                 std::forward<Args>(args)...);
+}
+
+// cref to function/callable
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncImpl(QFutureInterface<ResultType> &futureInterface,
+                  std::reference_wrapper<Function> functionWrapper, Args&&... args)
+{
+    runAsyncMemberDispatch(futureInterface, functionWrapper.get(), std::forward<Args>(args)...);
+}
+
+// function/callable, no cref
+template <typename ResultType, typename Function, typename... Args>
+void runAsyncImpl(QFutureInterface<ResultType> &futureInterface,
+                  Function &&function, Args&&... args)
+{
+    runAsyncMemberDispatch(futureInterface, std::forward<Function>(function),
+                           std::forward<Args>(args)...);
+}
+/*
+   AsyncJob is a QRunnable that wraps a function with the
+   arguments that are passed to it when it is run in a thread.
+*/
+
+template <class T>
+std::decay_t<T>
+decayCopy(T&& v)
+{
+    return std::forward<T>(v);
+}
+
+template <typename ResultType, typename Function, typename... Args>
+class AsyncJob : public QRunnable
+{
+public:
+    AsyncJob(Function &&function, Args&&... args)
+          // decay copy like std::thread
+        : data(decayCopy(std::forward<Function>(function)), decayCopy(std::forward<Args>(args))...)
+    {
+        // we need to report it as started even though it isn't yet, because someone might
+        // call waitForFinished on the future, which does _not_ block if the future is not started
+        futureInterface.setRunnable(this);
+        futureInterface.reportStarted();
+    }
+
+    ~AsyncJob() override
+    {
+        // QThreadPool can delete runnables even if they were never run (e.g. QThreadPool::clear).
+        // Since we reported them as started, we make sure that we always report them as finished.
+        // reportFinished only actually sends the signal if it wasn't already finished.
+        futureInterface.reportFinished();
+    }
+
+    QFuture<ResultType> future() { return futureInterface.future(); }
+
+    void run() override
+    {
+        if (priority != QThread::InheritPriority)
+            if (QThread *thread = QThread::currentThread())
+                if (thread != qApp->thread())
+                    thread->setPriority(priority);
+        if (futureInterface.isCanceled()) {
+            futureInterface.reportFinished();
+            return;
+        }
+        runHelper(std::make_index_sequence<std::tuple_size<Data>::value>());
+    }
+
+    void setThreadPool(QThreadPool *pool)
+    {
+        futureInterface.setThreadPool(pool);
+    }
+
+    void setThreadPriority(QThread::Priority p)
+    {
+        priority = p;
+    }
+
+private:
+    using Data = std::tuple<std::decay_t<Function>, std::decay_t<Args>...>;
+
+    template <std::size_t... index>
+    void runHelper(std::index_sequence<index...>)
+    {
+        // invalidates data, which is moved into the call
+        runAsyncImpl(futureInterface, std::move(std::get<index>(data))...);
+        if (futureInterface.isPaused())
+            futureInterface.waitForResume();
+        futureInterface.reportFinished();
+    }
+
+    Data data;
+    QFutureInterface<ResultType> futureInterface;
+    QThread::Priority priority = QThread::InheritPriority;
+};
+
+class RunnableThread : public QThread
+{
+public:
+    explicit RunnableThread(QRunnable *runnable, QObject *parent = nullptr);
+
+protected:
+    void run() override;
+
+private:
+    QRunnable *m_runnable;
+};
+
+template<typename Function,
+         typename... Args,
+         typename ResultType = typename Internal::resultType<Function>::type>
+QFuture<ResultType> runAsync_internal(QThreadPool *pool,
+                                      QThread::Priority priority,
+                                      Function &&function,
+                                      Args &&... args)
+{
+    auto job = new Internal::AsyncJob<ResultType,Function,Args...>
+            (std::forward<Function>(function), std::forward<Args>(args)...);
+    job->setThreadPriority(priority);
+    QFuture<ResultType> future = job->future();
+    if (pool) {
+        job->setThreadPool(pool);
+        pool->start(job);
+    } else {
+        auto thread = new Internal::RunnableThread(job);
+        thread->moveToThread(qApp->thread()); // make sure thread gets deleteLater on main thread
+        QObject::connect(thread, &QThread::finished, thread, &QObject::deleteLater);
+        thread->start(priority);
+    }
+    return future;
+}
+
+} // Internal
+
+/*!
+    The interface of \c {runAsync} is similar to the std::thread constructor and \c {std::invoke}.
+
+    The \a function argument can be a member function,
+    an object with \c {operator()} (with no overloads),
+    a \c {std::function}, lambda, function pointer or function reference.
+    The \a args are passed to the function call after they are copied/moved to the thread.
+
+    The \a function can take a \c {QFutureInterface<ResultType>&} as its first argument, followed by
+    other custom arguments which need to be passed to this function.
+    If it does not take a \c {QFutureInterface<ResultType>&} as its first argument
+    and its return type is not void, the function call's result is reported to the QFuture.
+    If \a function is a (non-static) member function, the first argument in \a args is expected
+    to be the object that the function is called on.
+
+    If a thread \a pool is given, the function is run there. Otherwise a new, independent thread
+    is started.
+
+    \sa std::thread
+    \sa std::invoke
+    \sa QThreadPool
+    \sa QThread::Priority
+ */
+template <typename Function, typename... Args,
+          typename ResultType = typename Internal::resultType<Function>::type>
+QFuture<ResultType>
+runAsync(QThreadPool *pool, QThread::Priority priority, Function &&function, Args&&... args)
+{
+    return Internal::runAsync_internal(pool,
+                                       priority,
+                                       std::forward<Function>(function),
+                                       std::forward<Args>(args)...);
+}
+
+/*!
+    Runs \a function with \a args in a new thread with given thread \a priority.
+    \sa runAsync(QThreadPool*,QThread::Priority,Function&&,Args&&...)
+    \sa QThread::Priority
+ */
+template <typename Function, typename... Args,
+          typename ResultType = typename Internal::resultType<Function>::type>
+QFuture<ResultType>
+runAsync(QThread::Priority priority, Function &&function, Args&&... args)
+{
+    return runAsync(static_cast<QThreadPool *>(nullptr), priority,
+                    std::forward<Function>(function), std::forward<Args>(args)...);
+}
+
+/*!
+    Runs \a function with \a args in a new thread with thread priority QThread::InheritPriority.
+    \sa runAsync(QThreadPool*,QThread::Priority,Function&&,Args&&...)
+    \sa QThread::Priority
+ */
+template <typename Function, typename... Args,
+          typename = std::enable_if_t<
+                !std::is_same<std::decay_t<Function>, QThreadPool>::value
+                && !std::is_same<std::decay_t<Function>, QThread::Priority>::value
+              >,
+          typename ResultType = typename Internal::resultType<Function>::type>
+QFuture<ResultType>
+runAsync(Function &&function, Args&&... args)
+{
+    return runAsync(static_cast<QThreadPool *>(nullptr),
+                    QThread::InheritPriority, std::forward<Function>(function),
+                    std::forward<Args>(args)...);
+}
+
+/*!
+    Runs \a function with \a args in a thread \a pool with thread priority QThread::InheritPriority.
+    \sa runAsync(QThreadPool*,QThread::Priority,Function&&,Args&&...)
+    \sa QThread::Priority
+ */
+template <typename Function, typename... Args,
+          typename = std::enable_if_t<!std::is_same<std::decay_t<Function>, QThread::Priority>::value>,
+          typename ResultType = typename Internal::resultType<Function>::type>
+QFuture<ResultType>
+runAsync(QThreadPool *pool, Function &&function, Args&&... args)
+{
+    return runAsync(pool, QThread::InheritPriority, std::forward<Function>(function),
+                    std::forward<Args>(args)...);
+}
+
+} // namespace Utils
diff --git a/src/spellcheckercore.cpp b/src/spellcheckercore.cpp
index 4954f2ce..6f2856bd 100644
--- a/src/spellcheckercore.cpp
+++ b/src/spellcheckercore.cpp
@@ -28,6 +28,7 @@
 #include "spellcheckercoresettings.h"
 #include "spellingmistakesmodel.h"
 #include "suggestionsdialog.h"
+#include "runextensions.h"
 
 #include <coreplugin/session.h>
 #include <coreplugin/icore.h>
@@ -43,9 +44,9 @@
 #include <coreplugin/idocument.h>
 #include <cppeditor/cppmodelmanager.h>
 #include <texteditor/texteditor.h>
+#include <utility>
 #include <utils/algorithm.h>
 #include <utils/fadingindicator.h>
-#include <utils/runextensions.h>
 #include <utils/fileutils.h>
 
 #include <QFuture>
diff --git a/src/spellcheckercoresettings.cpp b/src/spellcheckercoresettings.cpp
index 6ddc1e30..d8978e28 100644
--- a/src/spellcheckercoresettings.cpp
+++ b/src/spellcheckercoresettings.cpp
@@ -47,27 +47,27 @@ SpellCheckerCoreSettings::~SpellCheckerCoreSettings()
 {}
 // --------------------------------------------------
 
-void SpellCheckerCoreSettings::saveToSettings( QSettings* settings ) const
+void SpellCheckerCoreSettings::saveToSettings( Utils::QtcSettings* settings ) const
 {
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  settings->setValue( QLatin1String( Constants::SETTING_ACTIVE_SPELLCHECKER ),  activeSpellChecker );
-  settings->setValue( QLatin1String( Constants::SETTING_ONLY_PARSE_CURRENT ),   onlyParseCurrentFile );
-  settings->setValue( QLatin1String( Constants::SETTING_CHECK_EXTERNAL ),       checkExternalFiles );
-  settings->setValue( QLatin1String( Constants::PROJECTS_TO_IGNORE ),           projectsToIgnore );
-  settings->setValue( QLatin1String( Constants::REPLACE_ALL_FROM_RIGHT_CLICK ), replaceAllFromRightClick );
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  settings->setValue( Constants::SETTING_ACTIVE_SPELLCHECKER,  activeSpellChecker );
+  settings->setValue( Constants::SETTING_ONLY_PARSE_CURRENT,   onlyParseCurrentFile );
+  settings->setValue( Constants::SETTING_CHECK_EXTERNAL,       checkExternalFiles );
+  settings->setValue( Constants::PROJECTS_TO_IGNORE,           projectsToIgnore );
+  settings->setValue( Constants::REPLACE_ALL_FROM_RIGHT_CLICK, replaceAllFromRightClick );
   settings->endGroup(); /* CORE_SETTINGS_GROUP */
   settings->sync();
 }
 // --------------------------------------------------
 
-void SpellCheckerCoreSettings::loadFromSettings( QSettings* settings )
+void SpellCheckerCoreSettings::loadFromSettings( Utils::QtcSettings* settings )
 {
-  settings->beginGroup( QLatin1String( Constants::CORE_SETTINGS_GROUP ) );
-  activeSpellChecker       = settings->value( QLatin1String( Constants::SETTING_ACTIVE_SPELLCHECKER ), activeSpellChecker ).toString();
-  onlyParseCurrentFile     = settings->value( QLatin1String( Constants::SETTING_ONLY_PARSE_CURRENT ), onlyParseCurrentFile ).toBool();
-  checkExternalFiles       = settings->value( QLatin1String( Constants::SETTING_CHECK_EXTERNAL ), checkExternalFiles ).toBool();
-  projectsToIgnore         = settings->value( QLatin1String( Constants::PROJECTS_TO_IGNORE ), projectsToIgnore ).toStringList();
-  replaceAllFromRightClick = settings->value( QLatin1String( Constants::REPLACE_ALL_FROM_RIGHT_CLICK ), replaceAllFromRightClick ).toBool();
+  settings->beginGroup( Constants::CORE_SETTINGS_GROUP );
+  activeSpellChecker       = settings->value( Constants::SETTING_ACTIVE_SPELLCHECKER, activeSpellChecker ).toString();
+  onlyParseCurrentFile     = settings->value( Constants::SETTING_ONLY_PARSE_CURRENT, onlyParseCurrentFile ).toBool();
+  checkExternalFiles       = settings->value( Constants::SETTING_CHECK_EXTERNAL, checkExternalFiles ).toBool();
+  projectsToIgnore         = settings->value( Constants::PROJECTS_TO_IGNORE, projectsToIgnore ).toStringList();
+  replaceAllFromRightClick = settings->value( Constants::REPLACE_ALL_FROM_RIGHT_CLICK, replaceAllFromRightClick ).toBool();
   settings->endGroup(); /* CORE_SETTINGS_GROUP */
 }
 // --------------------------------------------------
diff --git a/src/spellcheckercoresettings.h b/src/spellcheckercoresettings.h
index 83f73f1f..77f8de77 100644
--- a/src/spellcheckercoresettings.h
+++ b/src/spellcheckercoresettings.h
@@ -20,6 +20,8 @@
 
 #pragma once
 
+#include "utils/qtcsettings.h"
+
 #include <QObject>
 #include <QSettings>
 
@@ -35,8 +37,8 @@ public:
   SpellCheckerCoreSettings( const SpellCheckerCoreSettings& settings );
   ~SpellCheckerCoreSettings();
 
-  void saveToSettings( QSettings* settings ) const;
-  void loadFromSettings( QSettings* settings );
+  void saveToSettings(Utils::QtcSettings* settings) const;
+  void loadFromSettings(Utils::QtcSettings* settings);
 
   SpellCheckerCoreSettings& operator=( const SpellCheckerCoreSettings& other );
   bool operator==( const SpellCheckerCoreSettings& other ) const;
